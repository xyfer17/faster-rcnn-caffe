
#include <caffe/caffe.hpp>
#include <opencv2/opencv.hpp>

#include <algorithm>
#include <iosfwd>
#include <memory>
#include <string>
#include <utility>
#include <vector>
#include <iostream>

using namespace caffe;
using namespace std;
using namespace cv;


Mat crop(Mat image, bool random_crop, int image_size)
{
    if(image.cols > image_size)
        {
            int h;
            int v;
            int sz1 = image.cols / 2;
            int sz2 = image_size / 2;
            if(random_crop == true)
                {
                    int diff;
                    diff = sz1-sz2;
                    h = rand() % (2*diff+1) + (-diff) ;
                    v = rand() % (2*diff+1) + (-diff) ;
                }
            else
                {
                    h=0;
                    v=0;
                }
            Rect roi = Rect(sz1-sz2+v, sz1-sz2+h,image_size,image_size);
            //Rect roi = Rect(sz1-sz2+v, sz1-sz2+h, sz1+sz2+v, sz1+sz2+h);
            Mat crop_img(image , roi);
            return crop_img;
        }
    return image;
}

Mat to_rgb(Mat img)
{
    // Mat res(img.rows,img.cols,CV_8UC3,Scalar(0,0,0));
    //for(int y=0;y<img.rows;y++)
    //    {
    //        for(int x=0;x<img.cols;x++)
    //            {
    //                int value = (int)(img.at<uchar>(y,x));
    //                Vec3b color = res.at<Vec3b>(Point(x,y));
//
    //                color[0] = value;
    //                color[1] = value;
    //                color[2] = value;
//
    //                res.at<Vec3b>(Point(x,y)) = color;
    //       }
    //    }
    
   cv::Mat sample;
   cv::cvtColor(img, sample, cv::COLOR_GRAY2BGR);
   return sample;
}

Mat flip(Mat image,bool random_flip)
{
    int f;
    f = rand() % 2;

    if(random_flip == true && f == 1)
        {
            Mat res;
            flip(image, res, 1);
            return res;
        }
    return image;
}

Mat prewhiten(Mat x)
{
//    Scalar mean, std, std_adj;
//    meanStdDev(x,mean,std);

//    float n = 1 / sqrt(3 * x.rows * x.cols) ;
//    for(int i=0;i<3;i++)
//        {
//            std_adj[i] = max(float(std[i]),n);
//        }

//    Mat m(x.rows, x.cols, CV_32FC3, Scalar(mean[0], mean[1], mean[2]));
//    Mat s(x.rows, x.cols, CV_32FC3, Scalar(1/std_adj[0],1/std_adj[1],1/std_adj[2]));

//    Mat res1, res2;

//    cv::Mat img_cvt;
//    x.convertTo(img_cvt, CV_32FC3);
//    subtract(img_cvt,m,res1);
//    res2 = res1.mul(s);

//    return res2;

Mat bgr[3];
split(x,bgr);

Mat t1,t2;
vconcat(bgr[0],bgr[1],t1);
vconcat(t1,bgr[2],t2);

Scalar mean,std;
float std_adj,std_adj1;
meanStdDev(t2,mean,std);

float n = 1/(sqrt(t2.rows * t2.cols));
std_adj = max(float(std[0]), n);
std_adj1 = 1/std_adj;

Mat m(x.rows, x.cols, CV_32FC3, Scalar(mean[0], mean[0], mean[0]));
Mat s(x.rows, x.cols, CV_32FC3, Scalar(std_adj1,std_adj1,std_adj1));

Mat res1, res2;

cv::Mat img_cvt;
x.convertTo(img_cvt, CV_32FC3);
subtract(img_cvt,m,res1);
res2 = res1.mul(s);

return res2;
}

Mat load_data(Mat image,bool do_random_crop,bool do_random_flip,int image_size,bool do_prewhiten = true)
{
        if(image.channels()==1)
                {
                        image = to_rgb(image);
                }

        if(do_prewhiten == true)
                {
                        image = prewhiten(image);
                }

        image = crop(image, do_random_crop, image_size);
        image = flip(image, do_random_flip);
        return image;
}


int main()
{
    string network = "/face-recognition/caffe/InceptionResnet128_correct.prototxt";
    string weights = "/face-recognition/caffe/Inception_ResnetV1_correct.caffemodel";
    string image_dir = "/face-recognition/caffe/dhoni2.jpg";
    Net<float> *net_ = new Net<float>(network,TEST);

    net_->CopyTrainedLayersFrom(weights);

    Caffe::set_mode(Caffe::CPU);

    Mat image = imread(image_dir);

    Mat img = load_data(image, false, false, 160);

    
    Blob<float>* input_layer = net_->input_blobs()[0];
    int num_channels_ = input_layer->channels();
    cv::Size input_geometry_;
    input_geometry_ = cv::Size(input_layer->width(), input_layer->height());

    input_layer->Reshape(1, num_channels_, input_geometry_.height, input_geometry_.width);
    net_->Reshape();

    std::vector<cv::Mat> input_channels;
   
    // WrapInputLayer(&input_channels);
    Blob<float>* input_layer1 = net_->input_blobs()[0];
    int width = input_layer1->width();
    int height = input_layer1->height();
    float* input_data = input_layer1->mutable_cpu_data();
    for (int i = 0; i < input_layer1->channels(); ++i) {
     cv::Mat channel(height, width, CV_32FC1, input_data);
     input_channels.push_back(channel);
     input_data += width * height;
 }

    cv::Mat sample_float;
    img.convertTo(sample_float, CV_32FC3);
    cv::split(sample_float, input_channels);
   
    CHECK(reinterpret_cast<float*>(input_channels.at(0).data)
        == net_->input_blobs()[0]->cpu_data())
    << "Input channels are not wrapping the input layer of the network.";

    net_->Forward();

    Blob<float>* output_layer = net_->output_blobs()[0];
    const float* begin = output_layer->cpu_data();
    const float* end = begin + output_layer->channels();
    std::vector<float> output;
    output = std::vector<float>(begin, end);

    for(int i=0;i<output.size();i++){
     cout<<output[i]<<" ";
    }
    cout<<endl<<output.size();
    cout<<endl<<"Hello";
    return 0;
}





